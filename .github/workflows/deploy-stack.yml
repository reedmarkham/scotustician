name: Deploy CloudFormation stack

on:
  workflow_call:
    inputs:
      stack_name:
        required: true
        type: string
      context_flags:
        required: false
        type: string
        default: ""
      gpu_quota_check:
        required: false
        type: boolean
        default: false
    secrets:
      AWS_REGION:
        required: true
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      S3_BUCKET:
        required: false
      AWS_IAM_ARN:
        required: true
    outputs:
      deployment_url:
        description: "Deployment URL if available"
        value: ${{ jobs.deploy.outputs.url }}

env:
  TOOLKIT_STACK: CDKToolkit-scotustician
  BOOTSTRAP_QUALIFIER: sctstcn
  CDK_DISABLE_VERSION_CHECK: true
  CDK_CLI_ASM_DISABLE: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    outputs:
      url: ${{ steps.get-url.outputs.url }}
    steps:
      - uses: actions/checkout@v3

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - uses: actions/setup-node@v3
        with:
          node-version: '20'

      - run: cd infrastructure && npm ci

      - name: Handle dependent stack exports
        if: ${{ inputs.stack_name == 'ScotusticianIngestStack' }}
        run: |
          echo "Checking for dependent stacks that use ingest exports..."
          
          # Define dependent stacks in deletion order (reverse dependency order)
          DEPENDENT_STACKS=("ScotusticianOrchestrationStack" "ScotusticianClusteringStack" "ScotusticianTransformersStack")
          
          # Check if any dependent stacks exist and delete them
          STACKS_TO_REDEPLOY=()
          
          for stack in "${DEPENDENT_STACKS[@]}"; do
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name $stack \
              --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
            
            if [[ "$STACK_STATUS" != "DOES_NOT_EXIST" ]]; then
              echo "Found dependent stack: $stack (status: $STACK_STATUS)"
              STACKS_TO_REDEPLOY+=($stack)
              
              echo "Deleting $stack to allow ingest stack update..."
              aws cloudformation delete-stack --stack-name $stack
              
              echo "Waiting for $stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name $stack
              echo "$stack deleted successfully"
            fi
          done
          
          # Store list of stacks to redeploy for later steps
          echo "STACKS_TO_REDEPLOY=${STACKS_TO_REDEPLOY[*]}" >> $GITHUB_ENV

      - name: Enhanced rollback recovery
        run: |
          STACK_NAME="${{ inputs.stack_name }}"
          MAX_RETRIES=1
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name $STACK_NAME \
              --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
            
            case $STACK_STATUS in
              "UPDATE_ROLLBACK_COMPLETE")
                echo "Stack ready for deployment (rollback complete)"
                break
                ;;
              "UPDATE_ROLLBACK_IN_PROGRESS")
                echo "Waiting for rollback to complete..."
                aws cloudformation wait stack-rollback-complete --stack-name $STACK_NAME 2>/dev/null
                break
                ;;
              "CREATE_IN_PROGRESS")
                echo "Stack is being created, waiting for completion..."
                aws cloudformation wait stack-create-complete --stack-name $STACK_NAME 2>/dev/null || true
                ;;
              "UPDATE_IN_PROGRESS")
                echo "Waiting for update to complete (timeout: 30 minutes)..."
                timeout 1800 aws cloudformation wait stack-update-complete --stack-name $STACK_NAME || {
                  echo "Update wait timed out or failed, checking current status..."
                  CURRENT_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "UNKNOWN")
                  echo "Current stack status: $CURRENT_STATUS"
                }
                ;;
              "UPDATE_ROLLBACK_FAILED")
                echo "Attempting to continue rollback..."
                aws cloudformation continue-update-rollback --stack-name $STACK_NAME 2>/dev/null || true
                aws cloudformation wait stack-rollback-complete --stack-name $STACK_NAME 2>/dev/null || true
                ;;
              "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS")
                echo "Waiting for cleanup to complete (timeout: 15 minutes)..."
                timeout 900 aws cloudformation wait stack-update-complete --stack-name $STACK_NAME || {
                  echo "Cleanup wait timed out or failed, checking current status..."
                  CURRENT_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "UNKNOWN")
                  echo "Current stack status after cleanup wait: $CURRENT_STATUS"
                  if [[ "$CURRENT_STATUS" == "UPDATE_COMPLETE" ]]; then
                    echo "Cleanup completed successfully"
                  else
                    echo "Stack may still be in cleanup, will proceed with deployment attempt"
                  fi
                }
                break
                ;;
              "ROLLBACK_COMPLETE")
                echo "ERROR: Stack in ROLLBACK_COMPLETE state - manual intervention required"
                exit 1
                ;;
              "CREATE_FAILED")
                echo "Stack creation failed, deleting failed stack..."
                aws cloudformation delete-stack --stack-name $STACK_NAME 2>/dev/null || true
                aws cloudformation wait stack-delete-complete --stack-name $STACK_NAME 2>/dev/null || true
                echo "Failed stack deleted, ready for fresh deployment"
                break
                ;;
              "DELETE_FAILED")
                echo "ERROR: Stack in DELETE_FAILED state - manual intervention required"
                exit 1
                ;;
              *)
                echo "Stack ready for deployment (status: $STACK_STATUS)"
                break
                ;;
            esac
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Waiting 30 seconds before retry..."
              sleep 30
            fi
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "ERROR: Max retries reached, stack not ready for deployment"
            exit 1
          fi

      - name: Pre-deployment validation
        run: |
          cd infrastructure
          npx cdk synth ${{ inputs.stack_name }} \
            --context awsIamArn=${{ secrets.AWS_IAM_ARN }} \
            --context @aws-cdk:bootstrap-qualifier=$BOOTSTRAP_QUALIFIER > /dev/null
          
          if aws cloudformation describe-stacks --stack-name ${{ inputs.stack_name }} >/dev/null 2>&1; then
            echo "Checking for stack drift..."
            DRIFT_ID=$(aws cloudformation detect-stack-drift \
              --stack-name ${{ inputs.stack_name }} \
              --query 'StackDriftDetectionId' --output text --no-cli-pager 2>/dev/null)
            
            sleep 10
            DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status \
              --stack-drift-detection-id $DRIFT_ID \
              --query 'StackDriftStatus' --output text --no-cli-pager 2>/dev/null)
              
            if [ "$DRIFT_STATUS" = "DRIFTED" ]; then
              echo "WARNING: Stack has drifted from expected state"
            fi
          fi

      - name: Check GPU quota
        if: ${{ inputs.gpu_quota_check }}
        id: gpu_check
        run: |
          echo "gpu_quota=0" >> $GITHUB_OUTPUT
          # Check G and VT instances quota (includes G4 instances)
          output=$(aws service-quotas get-service-quota \
            --service-code ec2 \
            --quota-code L-DB2E81BA \
            --query 'Quota.Value' --output text 2>&1) || true
          if [[ "$output" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
            echo "gpu_quota=$output" >> $GITHUB_OUTPUT
            echo "Found G4/VT quota: $output vCPUs"
          else
            echo "Could not retrieve G4/VT quota, output: $output"
          fi

      - name: Deploy stack with retry
        run: |
          cd infrastructure
          
          # Handle GPU context if needed
          CONTEXT_FLAGS="${{ inputs.context_flags }}"
          if [[ "${{ inputs.gpu_quota_check }}" == "true" ]]; then
            # G4DN.XLARGE needs 4 vCPUs, so check for at least 4
            if (( $(echo "${{ steps.gpu_check.outputs.gpu_quota }} >= 4" | bc -l) )); then
              CONTEXT_FLAGS="$CONTEXT_FLAGS --context useGpu=true"
              echo "Deploying with GPU context (G4DN instances available)"
            else
              CONTEXT_FLAGS="$CONTEXT_FLAGS --context useGpu=false"
              echo "Deploying with CPU fallback context (insufficient G4/VT quota: ${{ steps.gpu_check.outputs.gpu_quota }} vCPUs)"
            fi
          fi

          # Always add awsIamArn context from secret
          CONTEXT_FLAGS="$CONTEXT_FLAGS --context awsIamArn=${{ secrets.AWS_IAM_ARN }}"

          # Add S3 bucket context for visualization stack
          if [[ "${{ inputs.stack_name }}" == *"Visualization"* ]]; then
            CONTEXT_FLAGS="$CONTEXT_FLAGS --context s3BucketName=${{ secrets.S3_BUCKET }}"
          fi

          MAX_RETRIES=1
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            DEPLOY_CMD="npx cdk deploy ${{ inputs.stack_name }} \
              --context @aws-cdk:bootstrap-qualifier=$BOOTSTRAP_QUALIFIER \
              --toolkit-stack-name $TOOLKIT_STACK \
              $CONTEXT_FLAGS \
              --require-approval never \
              --method direct \
              --progress events"
            
            
            if eval $DEPLOY_CMD; then
              echo "Deployment successful"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Deployment failed, retrying in 60 seconds..."
                sleep 60
              else
                echo "All deployment attempts failed"
                exit 1
              fi
            fi
          done

      - name: Get deployment URL
        id: get-url
        if: ${{ contains(inputs.stack_name, 'Visualization') }}
        run: |
          URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ inputs.stack_name }} \
            --query 'Stacks[0].Outputs[?OutputKey==`VisualizationUrl`].OutputValue' \
            --output text 2>/dev/null || echo "")
          echo "url=$URL" >> $GITHUB_OUTPUT

      - name: Health check service
        if: ${{ contains(inputs.stack_name, 'Visualization') }}
        run: |
          ALB_URL="${{ steps.get-url.outputs.url }}"
          
          if [ -n "$ALB_URL" ]; then
            echo "Checking health of: $ALB_URL"
            
            for i in {1..30}; do
              if curl -f -s "$ALB_URL/_stcore/health" > /dev/null; then
                echo "Visualization service is healthy"
                break
              else
                echo "Attempt $i: Service not ready yet..."
                sleep 10
              fi
            done
            
            if ! curl -f -s "$ALB_URL/_stcore/health" > /dev/null; then
              echo "WARNING: Service health check failed after 5 minutes"
            fi
          fi

      - name: Create deployment summary
        if: ${{ contains(inputs.stack_name, 'Visualization') }}
        run: |
          URL="${{ steps.get-url.outputs.url }}"
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Stack:** ${{ inputs.stack_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "$URL" ]; then
            echo "**Visualization URL:** [$URL]($URL)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Status:** Deployed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** Deployed but URL not available" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY

      - name: Redeploy dependent stacks
        if: ${{ inputs.stack_name == 'ScotusticianIngestStack' && env.STACKS_TO_REDEPLOY != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Redeploying stacks that were deleted: $STACKS_TO_REDEPLOY"
          
          # Convert space-separated string back to array
          IFS=' ' read -ra STACKS_ARRAY <<< "$STACKS_TO_REDEPLOY"
          
          # Redeploy stacks directly using this workflow
          for ((i=${#STACKS_ARRAY[@]}-1; i>=0; i--)); do
            stack="${STACKS_ARRAY[i]}"
            echo "Deploying $stack..."
            
            # Deploy stack directly using CDK
            cd infrastructure && npx cdk deploy $stack \
              --context @aws-cdk:bootstrap-qualifier=$BOOTSTRAP_QUALIFIER \
              --toolkit-stack-name $TOOLKIT_STACK \
              --context awsIamArn=${{ secrets.AWS_IAM_ARN }} \
              --require-approval never \
              --method direct \
              --progress events
            
            echo "$stack redeployed successfully"
          done
          
          echo "All dependent stacks redeployed successfully"

